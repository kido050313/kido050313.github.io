<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[移动端一些常见问题及我的解决办法]]></title>
    <url>%2F2019%2F11%2F06%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E6%88%91%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7上部署基于nodejs的vue项目记录]]></title>
    <url>%2F2019%2F08%2F24%2Fdeploy%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;仿写了王者荣耀的官网和基于nodejs + express的后台，现在要将打包好的项目部署到线上，因为第一次做，所以在服务器上安装软件部署还是遇到了一些问题，这里记录一下。 git安装，配置ssh-key，同步github到码云&emsp;&emsp;为了方便部署，在服务器上安装git，直接拉取库里的文件，我这里为了稳定（并不是）之类的原因，选择了码云的库与服务器连接，配置ssh-key到对应项目即可，一开始项目是在github上的，在码云创建项目的时候，直接导入已有仓库，填入github的仓库地址。每次github更新，点击码云库名右边的强制更新icon，就可以同步了。 Node.js安装&emsp;&emsp; yum install -y nodejs安装nodejs, node -v查看版本，版本太低的话建议更新，安装npm并配置为淘宝镜像，nrm方便切换npm源，根据个人需求选择安装。安装n模块方便更新nodejs，n latest将node更新到最新版本，目前是12.6.0版本。 拉取代码，安装pm2并启动项目12cd /var/wwwgit clone git@gitee.com:xxx/xxx.git /var/www是你要服务器上的文件地址，xxx是你的项目地址，因为已经给服务器授权了，所以可以直接拉取，npm install 安装依赖，这里我遇到了问题，因为项目用到了bcrypt.js, npm install的时候报错了我：？？？？what?咋回事啊？目测是bcrypt.js有问题，查资料似乎在centos上bcrypt.js不存在，取而代之是node.bcrypt.js, 尝试了网上说的，下载node.bcrypt.js然后改名，并没有用。灵机一动，我为啥不去看Github上作者怎么说node.bcrypt.js, 我看到了什么！这不就是我现在吗?于是in this page找到了 CentOS这里，运行1yum install -y gcc-c++ make 然后再次尝试1npm install 欸嘿，虽然还有 WARN , 但是没有刺眼的 ERRO 了，成功之后运行项目，为了能够后台运行，避免ctrl+c退出后服务停止，这里选择了pm2进行控制，安装pm21npm install pm2 -g pm2的常用命令可以瞅瞅这里安装好之后启动服务12345678// start命令启动对应的node server文件pm2 start ./server/index.js// 查看所有启动的进程列表pm2 list // 检查是否启动成功curl http:localhost:3000 通过查看输出的内容可判断是否成功。 Nginx反向代理这里使用nginxconfig.io网站可以自动生成配置文件。选择nodejs，填入自己的域名或者ip地址，子域名(redirect subdomains)跳转不允许, https 不启用。反向代理端口号根据自己需要代理的填写然后下载文件或者复制到本地，上传到服务器上的nginx上，下载文件夹中的nginx.conf不需要上传，进入nginx文件夹中1cd /etc/nginx nginx文件夹下现在是这样的其中sites-enabled下是ln当前启用的站点,sites-available下有所有的（N个站点）配置，包括临时不启用的站点，其实下载下来的两个文件内容一样，但是我这边enabled 里面是available 的一个软链接，会报错，我这里就将sites-available下.conf的文件直接复制到sites-enabled解决报错。&emsp;&emsp;然后在nginx.conf 中添加123# load configsinclude /etc/nginx/conf.d/*.conf;include /etc/nginx/sites-enabled/*; 之后如果再有相关代理文件，可知直接放到这两个文件夹中，我这里一开始没有这两个文件夹，所以需要添加到nginx.conf中。&emsp;&emsp;设置完成之后，打开网址查看是否可以成功访问。 将本地数据迁移到服务器上（mongodump）直接在vscode 和git bash 输入mongodump导出命令无效，最后通过cmd窗口才能成功导出更多mongodb相关命令可以查看https://www.runoob.com/mongodb/mongodb-mongodump-mongorestore.html.将导出的数据文件上传到服务器，在服务器中将数据导入服务器上的数据库，1234mongorestore// 查看数据库show dbs 为了方便在本地查看服务器的数据库数据，本地可以选择安装Robo 3T连接服务器。&emsp;&emsp; 这次部署的过程和问题大概是这样。参考视频：https://www.bilibili.com/video/av58969687/?p=10]]></content>
      <categories>
        <category>服务器相关</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>mongodb</tag>
        <tag>nodejs</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7.6系统下安装mongodb3.6]]></title>
    <url>%2F2019%2F07%2F30%2FinstallMongodb%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;安装背景：阿里云服务器上的Centos7.6x64镜像，安装mongodb3.6版本的。试过了Yum方法，但是会有各种奇怪的错，最后在卸了装装了卸之后，选择了下载tgz包，然后上传到服务器进行解压安装。以下是辛酸的步骤。&emsp;&emsp;首先到mongodb官网下载mongodb3.6版本的安装包，你可以根据自己需要选择不同版本。&emsp;&emsp;下载完成后上传到centos上，我这里使用的是lrzsz上传压缩包，执行rz ,如果报错，先安装软件：yum -y install lrzsz。安装完成后 输入 rz 上传命令，出现弹窗，选择上传的文件。我选择将文件放在 /usr文件夹下&emsp;&emsp;上传成功后解压安装包，并且重命名解压的文件夹名12tar zxvf mongodb-linux-x86_64-3.6.13.tgzmv mongodb-linux-x86_64-3.6.13 mongodb &emsp;&emsp;cd mongodb进入文件夹可以看到里面的文件，如图所示&emsp;&emsp;配置环境变量,找到/etc下的proflie文件1vim /etc/profile &emsp;&emsp;在export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL这一行上面添加以下内容：12#Set Mongodbexport PATH=$PATH:/usr/mongodb/bin &emsp;&emsp;这里根据自己mongodb放置的路径写，不同的路径后面的文件路径也要对应更改。&emsp;&emsp;更改好之后退出返回系统根目录，然后通过更新配置文件使环境变量生效12cd ~source /etc/profile &emsp;&emsp;创建数据库目录,db 和log要记得创建，不要漏了，我因为漏了创建log启动报错了，创建的路径你可以根据自己放置的路径对应更改123456$ cd /usr/mongodb$ touch mongodb.conf$ mkdir db$ mkdir log$ cd log$ touch mongodb.log &emsp;&emsp;**：touch是创建一个空白文件，以及设置文件的时间。&emsp;&emsp;接下来修改mongodb.conf，添加以下内容，其中dbpath和logpath填写自己对应的自己文件路径。1234567891011port=27017 #端口dbpath= /usr/mongodb/db #数据库存文件存放目录logpath= /usr/mongodb/log/mongodb.log #日志文件存放路径logappend=true #使用追加的方式写日志fork=true #以守护进程的方式运行，创建服务器进程maxConns=100 #最大同时连接数noauth=true #不启用验证journal=true #每次写入会记录一条操作日志（通过journal可以重新构造出写入的数据）。#即使宕机，启动时wiredtiger会先将数据恢复到最近一次的checkpoint点，然后重放后续的journal日志来恢复。storageEngine=wiredTiger #存储引擎有mmapv1、wiretiger、mongorocksbind_ip = 0.0.0.0 #这样就可外部访问了，例如从win10中去连虚拟机中的MongoDB &emsp;&emsp;因为有可能会有权限问题，所以给文件夹设置权限123cd /usr/mongodbchmod 777 dbchmod 777 log &emsp;&emsp;设置完成之后，进入/usr/mongodb 然后执行 ./bin/mongo即可启动。如下图：按照其他资料说的，其他的启动命令都无效，不知道是不是因为我是安装包安装的问题，以上也有可能部分的命令无用，做到目前这一步，mongodb可以启动。个中原因以后学习深入会继续记录，并且进行补充。目前仅对安装步骤进行记录，以后再次安装可以再看看。 参考文章：https://blog.csdn.net/junshangshui/article/details/79371316 https://www.jianshu.com/p/994bc7b19b26 https://blog.csdn.net/xiaoguang44/article/details/80326043]]></content>
      <categories>
        <category>服务器相关</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增gitignore文件，但是需要过滤文件已经提交到远程库，如何解决]]></title>
    <url>%2F2019%2F06%2F12%2FgitMind%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;git提交文件时，发现如node_modules等本应过滤的文件也上传到了github上，经检查发现是缺少了gitinore文件，但是此时已经git commit了，撤回commit命令如下：&emsp;&emsp;git reset –soft HEAD^&emsp;&emsp;该命令仅撤回commit操作，其中HEAD^是指上一个版本，也可写作HEAD ~ 1,若commit了两次，可以使用HEAD~2。&emsp;&emsp;记录以下几个参数：&emsp;&emsp;–mixed&emsp;&emsp;不删除工作空间改动代码，撤销commit，并且撤销git add .操作。这个是默认参数，git reset –mixed HEAD^和git reset HEAD^效果一样。&emsp;&emsp;–soft不删除工作空间改动代码，撤销commit，不撤销git add.&emsp;&emsp;–hard删除工作空间改动代码，撤销commit,撤销git add .完成这个操作后，会恢复到上一次的commit状态。&emsp;&emsp;如果只是想修改commit注释，可以使用：&emsp;&emsp;git commit –amend进入默认vim编辑期，修改注释完毕后保存就好了。&emsp;&emsp;添加了gitignore文件之后再重新上传，过滤文件已经提交到远程库了，为了避免冲突，首先同步远程仓库。&emsp;&emsp;git pull然后删除本地项目目录下的缓存&emsp;&emsp;git rm -r –cached .&emsp;&emsp;然后再按照正常步骤提交到远程仓库就行了。&emsp;&emsp;提交的时候遇到了: “warning: LF will be replaced by CRLF”, 这是操作系统不同，换行符不同的原因，这里可以使用&emsp;&emsp;git config core.autocrlf然后会有三个输出：true，false, input我这里选了false.具体的可以看这篇文章：https://blog.csdn.net/starry_night9280/article/details/53207928 &emsp;&emsp; 最后push提交成功。 参考文章：https://www.cnblogs.com/lfxiao/p/9378763.html https://www.cnblogs.com/guanghuiz/p/6579902.html]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中日期字符串的转换]]></title>
    <url>%2F2019%2F03%2F07%2Fjs%E4%B8%AD%E6%97%A5%E6%9C%9F%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一些将日期格式进行转化的方法记录 一.字符串转日期&emsp;&emsp;将例如：2019-03-07 这种格式转为： 3月7日1234567891011121314151617function stringToDate(dateStr, separator) &#123; if(!separator) &#123; separator="-" &#125; var dateStr = dateStr.split(separator); var year = parseInt(dateStr[0]); var month; // 处理月份为03这种情况 if(dateStr[1].indexOf("0") == 0) &#123; month = parseInt(dateStr[1].substring(1)); &#125; else &#123; month = parseInt(dateStr[1]); &#125; var day = parseInt(dateStr[2]); var date = month + "月" + day + "日"; return date;&#125; 二. 时间戳转字符串&emsp;&emsp;如：1551949777658转成 2019-3-71234567function timesToString(timestamp) &#123; var _date = new Date(timestamp); // 根据时间戳生成的时间对象 var date = _date.getFullYear() + '-' + (_date.getMonth() + 1) + '-' + _date.getDate() return date;&#125; &emsp;&emsp;还有一些其他的转换没有接触到就不说了，总之就是利用js中的各种日期函数转和一些如分隔函数等方法灵活利用转换得到自己想要的格式。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>日期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序组件弹窗内跳转如何实现]]></title>
    <url>%2F2018%2F11%2F30%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E5%BC%B9%E7%AA%97%E5%86%85%E8%B7%B3%E8%BD%AC%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&emsp; &emsp;日常小程序踩坑，一个普通的页面点击弹出注册弹窗，然后注册成功要将一些参数传到跳转的页面，小程序的template主要用于展示，但是这里需要用到一些交互，所以最后选定component组件制作绑定手机号的弹窗页面。 &emsp; &emsp;1. 首先先将静态页面写好，这部分很简单直接放代码 123456789101112131415161718192021222324252627282930 // dialog.wxml&lt;view class="container"&gt; &lt;block wx:if="&#123;&#123;isShow? isShow: false&#125;&#125;"&gt; &lt;view class="toast-bg" wx:if="&#123;&#123;mask==false? false : true&#125;&#125;"&gt;&lt;/view&gt; &lt;view class="toast-center"&gt; &lt;view class="toast"&gt; &lt;view class="toastTop"&gt; &lt;view class="tips"&gt; &lt;text class="toast-text"&gt;验证手机号&lt;/text&gt; &lt;/view&gt; &lt;view class="phoneNum"&gt; &lt;input class="numberPh" cursor="10" type="number" maxlength="11" selection-start="-20" placeholder-class="placeholder" placeholder="请输入手机号码" bindinput="_bindKeyInput"/&gt; &lt;/view&gt; &lt;view class="verCode"&gt; &lt;input class="codePh" type="number" maxlength="4" placeholder-class="placeholder" placeholder="请输入验证码" bindinput="_bindKeyCode"/&gt; &lt;button hidden="&#123;&#123;isClick&#125;&#125;" class="getCode" bindtap="_sentCode" disabled="&#123;&#123;isGet&#125;&#125;"&gt;获取验证码&lt;/button&gt; &lt;button hidden="&#123;&#123;isClick == false&#125;&#125;" class="getCode" bindtap="_sentCode" disabled="&#123;&#123;isDisabled&#125;&#125;"&gt;重新发送&lt;/button&gt; &lt;button hidden="&#123;&#123;isCount&#125;&#125;" class="getCode gray" type="button" disabled="disabled"&gt;&#123;&#123;countText&#125;&#125;s&lt;/button&gt; &lt;view class="line"&gt;&lt;/view&gt; &lt;view class="erroReason"&gt;&#123;&#123;message&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;button disabled="&#123;&#123;isOk&#125;&#125;" class="codeSubmit" bindtap="_sent"&gt;提交&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="closeLose" bindtap="hideDialog"&gt; &lt;image src="../../images/icon/icon_close.png"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt;&lt;/view&gt; &emsp;&emsp;2. 自定义组件要在其json文件中显示的定义，很简单，如下： 1234 &#123; "component": true, "usingComponents": &#123;&#125;&#125; &emsp;&emsp;3. 主要就是js这一块，我遇到的主要问题是点击提交之后，要将父组件页面刷新，也就是执行父组件中的方法，查阅文档得知，父组件的方法无法传到子组件中，但是可以通过 “triggerEvent”进行组件中事件的通信（其实我觉得类似vue中的$emit），详细的可以看看文档介绍,这里只放主要代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// dialog.js _sent: function()&#123; // 通过triggerEvent()传给父组件 this.triggerEvent('submite'); &#125;, _submite: function(fn) &#123; //触发 var that = this; that.setData(&#123; isOk: true, &#125;) var groupNo = that.properties.groupNo; console.log(that.properties.groupNo); if (!that.data.phoneNum) &#123; that.setData(&#123; message: '手机号不能为空' &#125;) return; &#125; else if (!that.data.code) &#123; that.setData(&#123; message: '验证码不能为空' &#125;) return; &#125; else &#123; var _data = &#123; // 这里是参数 &#125; util.httpRequest(app.url + 'xxx/xxx', _data, function (res) &#123; console.log(res) var res = res.data; if (res.code == util.resCode.success) &#123; //更新缓存 wx.setStorage(&#123; key: 'userLoginInfo', data: res.data, &#125;) if (res.data.code == '20000')&#123; that.setData(&#123; message: '', isOk: false, &#125;) if (typeof fn == 'function') &#123; // 回调函数 fn(res); &#125; &#125; else &#123; that.setData(&#123; message: res.data.desc, isOk: false, &#125;) &#125; &#125; else &#123; that.setData(&#123; message: res.message, isOk: false, &#125;) &#125; &#125;) &#125; &#125; &emsp;&emsp; 父组件中利用bindtap接收，下面是父组件的wxml页面123// father.wxml&lt;!-- 注册组件 --&gt;&lt;dialog id="dialog" bind:submite="_sent" groupNo="&#123;&#123;groupNo&#125;&#125;"&gt;&lt;/dialog&gt; &emsp;&emsp; 父组件json文件中要注册组件123456// father.json&#123; "usingComponents": &#123; "dialog": "/common/bindMobile/index" &#125;&#125; &emsp;&emsp; 父组件js中页面渲染成功时，注册组件123456// father.jsonReady: function () &#123; var that = this; //引入注册组件 that.dialog = this.selectComponent("#dialog"); &#125; &emsp;&emsp; 父组件js中调用子组件传过来的方法12345678910// father.js//注册成功 _sent: function () &#123; var that = this; var groupNo = that.data.groupNo; that.dialog._submite(function (res) &#123; that.dialog.hideDialog(); //关闭弹窗 that.getJoindetail(); //刷新页面 &#125;, 500) &#125;, &emsp;&emsp;4. css样式，也没什么好说的 19：12，饿了饿了，溜了溜了，哒哒哒…]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序自定义顶部导航栏]]></title>
    <url>%2F2018%2F10%2F07%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%BC%E8%88%AA%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天开始了新的小程序踩坑，有一个需求是顶部导航栏需要渐变色，但是小程序的navigationBarBackgroundColor属性只支持有效的颜色值，不支持linear-gradient,最后选择了自定义导航栏开发。&emsp;&emsp;要使用小程序的自定义导航栏只需要在app.json中配置 目前小程序不支持单个页面设置，所以一旦决定使用自定义导航看，那么每个页面都要设置，为了方便我将其写成了一个组件 &emsp;&emsp; 组件目录： &emsp;&emsp; index.wxml文件:1234567891011121314151617181920212223&lt;view class="m-container"&gt; &lt;view class="navigate-title &#123;&#123;navbarData.isNormal == true?'normal':'linear'&#125;&#125;" style="padding-top:&#123;&#123;(statusBarHeight+titleBarHeight)*2&#125;&#125;rpx;"&gt;&lt;/view&gt; &lt;view class="header-title"&gt; &lt;view class="status-bar" style="height:&#123;&#123;statusBarHeight&#125;&#125;px;"&gt;&lt;/view&gt; &lt;view class="title-bar" style="height:&#123;&#123;titleBarHeight&#125;&#125;px"&gt; &lt;view class="left-icon" wx:if="&#123;&#123;navbarData.isBack&#125;&#125;"&gt; &lt;view wx:if="&#123;&#123;share&#125;&#125;"&gt; &lt;image bindtap="_backhome" class="u-home" src=''&gt;&lt;/image&gt; &lt;/view&gt; &lt;view wx:else&gt; &lt;block wx:if="&#123;&#123;navbarData.color == '#000'&#125;&#125;"&gt; &lt;image bindtap="_navback" class="navigator" src="../../images/icon/b_back.png"&gt;&lt;/image&gt; &lt;/block&gt; &lt;block wx:else&gt; &lt;image bindtap="_navback" class="navigator" src="../../images/icon/w_back.png"&gt;&lt;/image&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="title" style="color:&#123;&#123;navbarData.color&#125;&#125;;"&gt;&#123;&#123;navbarData.title&#125;&#125;&lt;/view&gt; &lt;view class="right-icon"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; &emsp;&emsp;index.wxss文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748.header-title &#123; position: fixed; top: 0; width: 100%; z-index: 9999;&#125;.linear &#123; background: linear-gradient(90deg,#FFC426,#F99120);&#125;.normal &#123; background: #FFFCF8;&#125;.right-icon &#123; width: 100rpx; height: 100rpx; float: right;&#125;.title &#123; text-align: center; line-height: 100rpx; font-size: 38rpx;&#125;.title-bar &#123; width: 100%; overflow: hidden;&#125;.left-icon &#123; width: 100rpx; height: 100rpx; float: left;&#125;/* 返回首页 */.u-home &#123; width: 36rpx; height: 36rpx; float: left; margin-top: 32rpx; margin-left: 35rpx;&#125;/*箭头部分*/.navigator &#123; width: 18rpx; height: 34rpx; float: left; margin-top: 32rpx; /* background: #FFF; */ margin-left: 35rpx;&#125; &emsp;&emsp;index.js文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// common/navbar/index.jsconst app = getApp();Component(&#123; options: &#123; multipleSlots: true, // 在组件定义时的选项中启用多slot支持 &#125;, /** * 组件的属性列表 */ properties: &#123; navbarData: &#123; //navbarData 由父页面传递的数据，变量名字自命名 type: Object, value: &#123;&#125;, observer: function (newVal, oldVal) &#123; &#125; &#125; &#125;, /** * 组件的初始数据 */ data: &#123; statusBarHeight: '', titleBarHeight: '', //默认值，默认不显示 navbarData: &#123; isBack: '' &#125; &#125;, attached: function(res)&#123; // 获取是否是通过分享进入的小程序 this.setData(&#123; share: app.globalData.share &#125;) // 定义导航栏的高度 方便对齐 this.setData(&#123; statusBarHeight: wx.getStorageSync('statusBarHeight'), titleBarHeight: wx.getStorageSync('titleBarHeight') &#125;) &#125;, /** * 组件的方法列表 */ methods: &#123; // 返回上一页面 _navback() &#123; wx.navigateBack() &#125;, //返回到首页 _backhome() &#123; wx.switchTab(&#123; url: '/pages/index/index', &#125;) &#125; &#125;,&#125;) &emsp;&emsp;index.json文件: 1234&#123; "component": true, "usingComponents": &#123;&#125;&#125; &emsp;&emsp;app.js文件: 123456789101112131415161718192021222324252627282930313233343536373839//app.jsconst util = require("utils/util.js");App(&#123; onLaunch: function (options) &#123; var _this = this // 判断是否由分享进入小程序 if (options.scene == 1007 || options.scene == 1008) &#123; _this.globalData.share = true &#125; else &#123; _this.globalData.share = false &#125;; wx.getSystemInfo(&#123; success: function (res) &#123; console.log(res) // 采用百分比适配不同的安卓手机，主要针对刘海屏安卓手机(此方法有待完善) let screenHeight = res.windowHeight; let totalTopHeight = parseInt(screenHeight / 8) if (res.model.indexOf('iPhone X') !== -1) &#123; totalTopHeight = 88 &#125; else if (res.model.indexOf('iPhone') !== -1) &#123; totalTopHeight = 64 &#125; wx.setStorageSync('statusBarHeight', res.statusBarHeight) wx.setStorageSync('titleBarHeight', totalTopHeight - res.statusBarHeight) &#125;, failure() &#123; wx.setStorageSync('statusBarHeight', 0) wx.setStorageSync('titleBarHeight', 0) &#125; &#125;) &#125;, globalData: &#123; userLoginInfo: null, share: false, //分享默认为false &#125;, userLogin: function(res)&#123; console.log(res) &#125;&#125;) 如何使用自定义导航栏：在微信小程序页面中：pages文件夹index.wxml文件： 1234// 引入自定义组价。&apos;navbar-data&apos;中header是自定义名字，决定了组件中&apos;navbarData&apos;的名字&lt;view class=&quot;container&quot;&gt; &lt;header navbar-data=&apos;&#123;&#123;nvabarData&#125;&#125;&apos;&gt;&lt;/header&gt;&lt;/view&gt; &emsp;&emsp;pages文件夹index.json文件中(声明使用的组件，和组件的地址)：123&quot;usingComponents&quot;: &#123; &quot;header&quot;: &quot;/common/navbar/index&quot; &#125; &emsp;&emsp;pages文件夹index.js文件：1234567891011121314151617const app = getApp()Page(&#123; /** * 页面的初始数据 */ data: &#123; // 组件所需的参数 nvabarData: &#123; isBack: &apos;&apos;, //是否显示左上角图标 title: &apos;首页&apos;, //导航栏 中间的标题 isNormal: true, //导航栏背景颜色 false为渐变色 color: &apos;#000&apos;, //导航栏字体颜色 &#125;, &#125;,)&#125; 由自定义组件引发的一些问题： 下拉刷新; 安卓手机适配，目前我暂时还没想到好的办法。 美好的国庆又这样结束了，这次飞了五个机场，有差不多两天的时间都在路上，很累但是很开心。人生尚未结束，同志还需努力鸭。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>顶部导航栏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序实现批量删除，全选，取消全选功能的一些总结]]></title>
    <url>%2F2018%2F09%2F03%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近有一个小程序需求是批量删除，全选和取消全选，这次记录一下这次遇到的问题。 &emsp;&emsp;一开始打算用小程序的组建checkbox实现的，但是之后发现checkbox的checked属性是单向绑定不支持双向绑定，我在实现全选和取消功能时候需要在js中更改checked的值，在文档中没有明确的说明checked是单向的，最后在社区的官方回答中找到了这个。自己回过头又仔细看了文档果然用了“设置默认选中”说明了，也有可能我太菜了所以没看出来，不管怎么样，最后我换成了view。 &emsp;&emsp;这次实现的逻辑： &emsp;&emsp;1. 点击编辑弹出全选+取消全选按钮，编辑按钮变成不可点击的删除按钮，同时每条记录前有选择按钮； &emsp;&emsp;2. 点击全选所有的选项都是选中状态，点击取消则全不选中； &emsp;&emsp;3. 单选时，没有选中的话就是点击就是选中，item.checked为true控制页面选中样式，反之item.checked= false时为取消选中状态； &emsp;&emsp;4. 如果全选状态下，列表中某一项取消选中，全选样式改变； &emsp;&emsp;5. 点击删除将选中记录的id数组传给后台进行删除。 &emsp;&emsp; js文件中data数据如下： 12345678910111213141516data: &#123; isFooter: false, doneHistory: true, flagHistory: true, hidden: false, icon: &quot;../../images/icon/Shape3.png&quot;, removeIndex: [], removeHistoryId: [], historyList: [], loading: false, isHeader: true, //选框状态 isClick: true, //删除按钮 isChoose: true, //是否选中 isChecked: false,//全选状态 deleteNum: &apos;&apos;, //删除个数&#125;, &emsp;&emsp; 在通过修改item.checked为true控制页面选中样式时，遇到了数组中的checked属性无法进行实时刷新，最后参考了一些文章找到了方法. 12345var itemIndex = e.target.dataset.index;//当前点击的下标var newChecked = &apos;historyList[&apos; + itemIndex + &apos;].checked&apos;; //重点，拼成字符串 that.setData(&#123; [newChecked]: !that.data.historyList[itemIndex].checked //用中括号括起来即可 &#125;) 参考文档：https://blog.csdn.net/stp_zsj/article/details/81979669&emsp;&emsp; &emsp;&emsp;&ensp;https://www.cnblogs.com/simuhunluo/p/7989461.html&emsp;&emsp; 使用splice()通过删除被选中项的下标实现删除功能12345678910111213141516var _reIndex = that.data.removeIndex; for (var i = 0; i &lt; _reIndex.length;i++)&#123; var _index = _reIndex[i]; console.log(_index) that.data.historyList.splice(_index, 1); &#125; that.setData(&#123; historyList: that.data.historyList, isChoose: true, removeHistoryId: [], removeIndex: [], deleteNum: &apos;&apos;, isHeader: true, isClick: true, isDelete: true, &#125;); &emsp;&emsp;其他的都挺简单的，主要是自己的做的时候把自己绕晕了，还有就是光想是不够的还要动手实践了才行。最后放出丑丑效果图 —最后20：35了，赶紧跑……]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
</search>
